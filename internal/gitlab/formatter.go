package gitlab

import (
	"fmt"
	"strings"

	"github.com/handsoff/handsoff/internal/llm"
)

// FormatReviewComment formats LLM review response as a GitLab Markdown comment
func FormatReviewComment(response *llm.ReviewResponse) string {
	var sb strings.Builder

	// Header
	sb.WriteString("## ðŸ¤– AI Code Review\n\n")

	// Summary section
	sb.WriteString("### ðŸ“ Summary\n\n")
	if response.Summary != "" {
		sb.WriteString(response.Summary)
		sb.WriteString("\n\n")
	} else {
		sb.WriteString("_No summary provided_\n\n")
	}

	// Score section
	sb.WriteString(fmt.Sprintf("**Quality Score:** %d/100\n\n", response.Score))

	// Suggestions section
	if len(response.Suggestions) > 0 {
		sb.WriteString(fmt.Sprintf("### ðŸ” Issues Found (%d)\n\n", len(response.Suggestions)))

		// Group by severity
		criticalIssues := filterBySeverity(response.Suggestions, "critical")
		highIssues := filterBySeverity(response.Suggestions, "high")
		mediumIssues := filterBySeverity(response.Suggestions, "medium")
		lowIssues := filterBySeverity(response.Suggestions, "low")

		if len(criticalIssues) > 0 {
			sb.WriteString("#### ðŸ”´ Critical Issues\n\n")
			formatIssueTable(&sb, criticalIssues)
		}

		if len(highIssues) > 0 {
			sb.WriteString("#### ðŸŸ  High Priority\n\n")
			formatIssueTable(&sb, highIssues)
		}

		if len(mediumIssues) > 0 {
			sb.WriteString("#### ðŸŸ¡ Medium Priority\n\n")
			formatIssueTable(&sb, mediumIssues)
		}

		if len(lowIssues) > 0 {
			sb.WriteString("#### ðŸŸ¢ Low Priority\n\n")
			formatIssueTable(&sb, lowIssues)
		}
	} else {
		sb.WriteString("### âœ… No Issues Found\n\n")
		sb.WriteString("Great work! The code looks good.\n\n")
	}

	// Footer
	sb.WriteString("---\n\n")
	sb.WriteString(fmt.Sprintf("_Generated by HandsOff AI Code Review | Model: %s | Tokens: %d | Duration: %.2fs_\n",
		response.ModelUsed, response.TokensUsed, response.Duration.Seconds()))

	return sb.String()
}

// formatIssueTable formats a list of suggestions as a Markdown table
func formatIssueTable(sb *strings.Builder, suggestions []llm.FixSuggestion) {
	sb.WriteString("| File | Lines | Category | Description |\n")
	sb.WriteString("|------|-------|----------|-------------|\n")

	for _, sug := range suggestions {
		filePath := sug.FilePath
		if filePath == "" {
			filePath = "_general_"
		}

		lineInfo := formatLineRange(sug.LineStart, sug.LineEnd)
		category := sug.Category
		if category == "" {
			category = "other"
		}

		// Truncate description if too long
		description := sug.Description
		if len(description) > 100 {
			description = description[:97] + "..."
		}

		sb.WriteString(fmt.Sprintf("| `%s` | %s | **%s** | %s |\n",
			filePath, lineInfo, category, description))
	}

	sb.WriteString("\n")

	// Detailed suggestions
	sb.WriteString("<details>\n<summary>ðŸ“‹ Detailed Suggestions</summary>\n\n")
	for i, sug := range suggestions {
		sb.WriteString(fmt.Sprintf("**%d. %s**\n\n", i+1, sug.Description))

		if sug.FilePath != "" {
			sb.WriteString(fmt.Sprintf("- **File:** `%s`\n", sug.FilePath))
			sb.WriteString(fmt.Sprintf("- **Lines:** %s\n", formatLineRange(sug.LineStart, sug.LineEnd)))
		}

		if sug.Category != "" {
			sb.WriteString(fmt.Sprintf("- **Category:** %s\n", sug.Category))
		}

		if sug.Suggestion != "" {
			sb.WriteString(fmt.Sprintf("\n**Recommendation:**\n%s\n", sug.Suggestion))
		}

		if sug.CodeSnippet != "" {
			sb.WriteString("\n**Current Code:**\n```\n")
			sb.WriteString(sug.CodeSnippet)
			sb.WriteString("\n```\n")
		}

		sb.WriteString("\n---\n\n")
	}
	sb.WriteString("</details>\n\n")
}

// filterBySeverity filters suggestions by severity level
func filterBySeverity(suggestions []llm.FixSuggestion, severity string) []llm.FixSuggestion {
	var filtered []llm.FixSuggestion
	for _, sug := range suggestions {
		if strings.EqualFold(sug.Severity, severity) {
			filtered = append(filtered, sug)
		}
	}
	return filtered
}

// formatLineRange formats line range display
func formatLineRange(start, end int) string {
	if start == 0 && end == 0 {
		return "-"
	}
	if start == end {
		return fmt.Sprintf("L%d", start)
	}
	return fmt.Sprintf("L%d-L%d", start, end)
}
